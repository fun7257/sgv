package env

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"sync"

	"github.com/fun7257/sgv/internal/config"
	"github.com/fun7257/sgv/internal/version"
)

var (
	// protectedVars are Go built-in environment variables that should not be modified
	protectedVars = map[string]bool{
		"GOROOT":      true,
		"GOPATH":      true,
		"GOPROXY":     true,
		"GOSUMDB":     true,
		"GONOPROXY":   true,
		"GONOSUMDB":   true,
		"GOPRIVATE":   true,
		"GO111MODULE": true,
		"GOOS":        true,
		"GOARCH":      true,
		"CGO_ENABLED": true,
	}

	// envVarRegex validates environment variable names
	envVarRegex = regexp.MustCompile(`^[A-Za-z_][A-Za-z0-9_]*$`)

	// mutex for file operations
	fileMutex sync.Mutex
)

// EnvVars represents a collection of environment variables
type EnvVars map[string]string

// GetEnvDir returns the environment directory path
func GetEnvDir() string {
	return filepath.Join(config.SgvRoot, "env")
}

// GetEnvFile returns the environment file path for a given version
func GetEnvFile(version string) string {
	return filepath.Join(GetEnvDir(), version+".env")
}

// IsProtectedVar checks if a variable is protected
func IsProtectedVar(key string) bool {
	return protectedVars[strings.ToUpper(key)]
}

// ValidateVarName validates environment variable name format
func ValidateVarName(name string) error {
	if !envVarRegex.MatchString(name) {
		return fmt.Errorf("invalid environment variable name: %s", name)
	}
	return nil
}

// LoadEnvVars loads environment variables for the given version
func LoadEnvVars(version string) (EnvVars, error) {
	envFile := GetEnvFile(version)
	vars := make(EnvVars)

	// Check if file exists
	if _, err := os.Stat(envFile); os.IsNotExist(err) {
		return vars, nil // Return empty vars if file doesn't exist
	}

	fileMutex.Lock()
	defer fileMutex.Unlock()

	file, err := os.Open(envFile)
	if err != nil {
		return nil, fmt.Errorf("failed to open env file: %w", err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	lineNum := 0
	for scanner.Scan() {
		lineNum++
		line := strings.TrimSpace(scanner.Text())

		// Skip empty lines and comments
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// Parse KEY=VALUE
		parts := strings.SplitN(line, "=", 2)
		if len(parts) != 2 {
			return nil, fmt.Errorf("invalid format at line %d: %s", lineNum, line)
		}

		key := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])

		if err := ValidateVarName(key); err != nil {
			return nil, fmt.Errorf("line %d: %w", lineNum, err)
		}

		vars[key] = value
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("failed to read env file: %w", err)
	}

	return vars, nil
}

// SaveEnvVars saves environment variables for the given version
func SaveEnvVars(version string, vars EnvVars) error {
	envDir := GetEnvDir()
	envFile := GetEnvFile(version)

	// Ensure env directory exists
	if err := os.MkdirAll(envDir, 0755); err != nil {
		return fmt.Errorf("failed to create env directory: %w", err)
	}

	fileMutex.Lock()
	defer fileMutex.Unlock()

	// Write to temporary file first for atomic operation
	tmpFile := envFile + ".tmp"
	file, err := os.Create(tmpFile)
	if err != nil {
		return fmt.Errorf("failed to create temp file: %w", err)
	}
	defer func() {
		file.Close()
		os.Remove(tmpFile) // Clean up on error
	}()

	// Write header comment
	fmt.Fprintf(file, "# Environment variables for Go version %s\n", version)
	fmt.Fprintf(file, "# Generated by sgv - do not edit manually\n\n")

	// Sort keys for consistent output
	keys := make([]string, 0, len(vars))
	for key := range vars {
		keys = append(keys, key)
	}
	sort.Strings(keys)

	// Write variables
	for _, key := range keys {
		fmt.Fprintf(file, "%s=%s\n", key, vars[key])
	}

	if err := file.Close(); err != nil {
		return fmt.Errorf("failed to close temp file: %w", err)
	}

	// Atomic rename
	if err := os.Rename(tmpFile, envFile); err != nil {
		return fmt.Errorf("failed to rename temp file: %w", err)
	}

	return nil
}

// SetEnvVar sets an environment variable for the given version
func SetEnvVar(version, key, value string) error {
	// Validate variable name
	if err := ValidateVarName(key); err != nil {
		return err
	}

	// Check if variable is protected
	if IsProtectedVar(key) {
		return fmt.Errorf("%s is a protected environment variable and cannot be modified", key)
	}

	// Load existing variables
	vars, err := LoadEnvVars(version)
	if err != nil {
		return fmt.Errorf("failed to load existing variables: %w", err)
	}

	// Set the variable
	vars[key] = value

	// Save variables
	if err := SaveEnvVars(version, vars); err != nil {
		return fmt.Errorf("failed to save variables: %w", err)
	}

	return nil
}

// UnsetEnvVar removes an environment variable for the given version
func UnsetEnvVar(version, key string) error {
	// Validate variable name
	if err := ValidateVarName(key); err != nil {
		return err
	}

	// Check if variable is protected
	if IsProtectedVar(key) {
		return fmt.Errorf("%s is a protected environment variable and cannot be removed", key)
	}

	// Load existing variables
	vars, err := LoadEnvVars(version)
	if err != nil {
		return fmt.Errorf("failed to load existing variables: %w", err)
	}

	// Check if variable exists
	if _, exists := vars[key]; !exists {
		return fmt.Errorf("environment variable %s not found", key)
	}

	// Remove the variable
	delete(vars, key)

	// Save variables
	if err := SaveEnvVars(version, vars); err != nil {
		return fmt.Errorf("failed to save variables: %w", err)
	}

	return nil
}

// ClearAllEnvVars removes all environment variables for the given version
func ClearAllEnvVars(version string) error {
	// Load existing variables to check if any exist
	vars, err := LoadEnvVars(version)
	if err != nil {
		return fmt.Errorf("failed to load existing variables: %w", err)
	}

	if len(vars) == 0 {
		return fmt.Errorf("no environment variables found for version %s", version)
	}

	// Clear all variables by saving an empty map
	emptyVars := make(EnvVars)
	if err := SaveEnvVars(version, emptyVars); err != nil {
		return fmt.Errorf("failed to clear variables: %w", err)
	}

	// Remove the env file if it's empty
	envFile := GetEnvFile(version)
	if err := os.Remove(envFile); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to remove env file: %w", err)
	}

	return nil
}

// GetCurrentVersion returns the current active Go version
func GetCurrentVersion() (string, error) {
	currentVersion, err := version.GetCurrentVersion()
	if err != nil {
		return "", fmt.Errorf("failed to get current version: %w", err)
	}

	if currentVersion == "" {
		return "", fmt.Errorf("no Go version is currently active")
	}

	return currentVersion, nil
}

// GetAllEnvVars returns all environment variables for all versions
func GetAllEnvVars() (map[string]EnvVars, error) {
	envDir := GetEnvDir()
	allVars := make(map[string]EnvVars)

	// Check if env directory exists
	if _, err := os.Stat(envDir); os.IsNotExist(err) {
		return allVars, nil
	}

	entries, err := os.ReadDir(envDir)
	if err != nil {
		return nil, fmt.Errorf("failed to read env directory: %w", err)
	}

	for _, entry := range entries {
		if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".env") {
			version := strings.TrimSuffix(entry.Name(), ".env")
			vars, err := LoadEnvVars(version)
			if err != nil {
				return nil, fmt.Errorf("failed to load env vars for %s: %w", version, err)
			}
			if len(vars) > 0 {
				allVars[version] = vars
			}
		}
	}

	return allVars, nil
}

// GetActiveEnvVars returns a list of environment variable names that are currently active
func GetActiveEnvVars() ([]string, error) {
	allVars, err := GetAllEnvVars()
	if err != nil {
		return nil, err
	}

	activeVars := make(map[string]bool)
	for _, vars := range allVars {
		for key := range vars {
			activeVars[key] = true
		}
	}

	result := make([]string, 0, len(activeVars))
	for key := range activeVars {
		result = append(result, key)
	}
	sort.Strings(result)
	return result, nil
}
